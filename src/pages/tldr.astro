---
import "../styles/global.css";
const title = "TL;DR — stanwood.dev";
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{title}</title>
    <meta
      name="description"
      content="I don't want to read this long PDF. Tell me what it says."
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: 'Inter', system-ui, sans-serif;
        background: #0f0f0f;
        min-height: 100vh;
        position: relative;
      }

      /* subtle noise overlay */
      body::before {
        content: '';
        position: fixed;
        inset: 0;
        opacity: 0.03;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
        pointer-events: none;
        z-index: 0;
      }

      main { position: relative; z-index: 1; }

      .drop-zone {
        transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s;
        border: 2px dashed #333;
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.05), inset 0 0 20px rgba(0, 212, 255, 0.02);
      }
      .drop-zone:hover {
        border-color: #00D4FF50;
        box-shadow: 0 0 30px rgba(0, 212, 255, 0.1), inset 0 0 30px rgba(0, 212, 255, 0.03);
      }
      .drop-zone.dragover {
        border-color: #00D4FF;
        background-color: rgba(0, 212, 255, 0.05);
        box-shadow: 0 0 40px rgba(0, 212, 255, 0.2), inset 0 0 40px rgba(0, 212, 255, 0.05);
      }

      /* compact drop zone when shown after result */
      .drop-zone.compact {
        padding-top: 2rem;
        padding-bottom: 2rem;
      }
      .drop-zone.compact svg {
        height: 1.5rem;
        width: 1.5rem;
      }

      /* pulsing glow on idle */
      @keyframes pulseGlow {
        0%, 100% { box-shadow: 0 0 20px rgba(0, 212, 255, 0.05); }
        50% { box-shadow: 0 0 30px rgba(0, 212, 255, 0.12); }
      }
      .drop-zone:not(.dragover) {
        animation: pulseGlow 3s ease-in-out infinite;
      }

      .fade-in {
        animation: fadeIn 0.4s ease-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(12px); }
        to   { opacity: 1; transform: translateY(0); }
      }

      /* terminal cursor blink */
      @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
      }
      .terminal-cursor {
        display: inline-block;
        width: 2px;
        height: 1em;
        background: #00D4FF;
        margin-left: 2px;
        vertical-align: text-bottom;
        animation: blink 0.8s step-end infinite;
      }

      .mono { font-family: 'JetBrains Mono', monospace; }

      /* typewriter title */
      .typewriter-title {
        display: inline;
      }
      .typewriter-title .char {
        opacity: 0;
      }
      .typewriter-title .char.visible {
        opacity: 1;
      }

      /* progress bar */
      .progress-track {
        height: 4px;
        background: #2a2a3e;
        border-radius: 2px;
        overflow: hidden;
        width: 100%;
        max-width: 280px;
      }
      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #00D4FF, #4ADE80);
        border-radius: 2px;
        transition: width 0.3s ease-out;
        width: 0%;
      }

    </style>
  </head>

  <body class="text-[#E4E4E7] antialiased">
    <main class="mx-auto max-w-2xl px-6 pt-16 pb-24">
      <!-- Top bar -->
      <div class="flex items-center">
        <a
          href="/"
          class="text-sm font-medium text-[#71717A] hover:text-[#00D4FF] transition-colors mono"
        >
          &larr; home
        </a>
      </div>

      <!-- Header -->
      <header class="mt-10">
        <h1 class="text-5xl font-bold tracking-tight text-white mono">
          <span id="typewriter" class="typewriter-title"><span class="char">T</span><span class="char">L</span><span class="char">;</span><span class="char">D</span><span class="char">R</span></span><span id="cursor" class="terminal-cursor"></span>
        </h1>
        <p class="mt-4 text-[#71717A] leading-relaxed max-w-lg">
          You got a long PDF and you don't want to read it. Same.
          Drop it here and get the short version &mdash; plain language,
          no jargon, just what it actually says.
        </p>
      </header>

      <!-- Upload zone -->
      <section id="uploadSection" class="mt-10">
        <div
          id="dropZone"
          class="drop-zone relative flex flex-col items-center justify-center rounded-2xl bg-[#1e1e2e] px-8 py-20 text-center cursor-pointer"
        >
          <div id="uploadPrompt">
            <svg class="mx-auto h-10 w-10 text-[#333]" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m6.75 12-3-3m0 0-3 3m3-3v6m-1.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" />
            </svg>
            <p class="mt-4 text-sm font-medium text-[#E4E4E7]">
              Drop a PDF here, or click to upload.
            </p>
            <p class="mt-1 text-xs text-[#71717A]">
              Sent to AI for summarization, then discarded.
            </p>
          </div>

          <!-- Loading state (hidden by default) -->
          <div id="loadingState" class="hidden">
            <p id="fileName" class="text-xs text-[#71717A] mono rounded-full bg-[#2a2a3e] px-3 py-1 inline-block"></p>
            <div class="mt-4 flex flex-col items-center gap-2">
              <div class="progress-track">
                <div id="progressFill" class="progress-fill"></div>
              </div>
              <span id="progressLabel" class="text-xs text-[#71717A] mono">Reading...</span>
            </div>
          </div>

          <input
            id="fileInput"
            type="file"
            accept="application/pdf"
            class="absolute inset-0 h-full w-full cursor-pointer opacity-0"
          />
        </div>
      </section>

      <!-- Result -->
      <section id="resultSection" class="mt-8 hidden">
        <div class="fade-in rounded-2xl border-l-4 border-[#4ADE80] bg-[#1e1e2e] shadow-lg">
          <div class="px-8 py-8">
            <div class="flex items-center justify-between mb-4">
              <h2 class="text-xs font-semibold uppercase tracking-widest text-[#4ADE80] mono">
                Summary
              </h2>
              <button
                id="copyBtn"
                class="rounded-lg px-3 py-1.5 text-xs font-medium text-[#71717A] hover:text-[#00D4FF] hover:bg-[#2a2a3e] transition-colors mono"
              >
                copy
              </button>
            </div>
            <p id="summaryText" class="text-base leading-relaxed text-[#E4E4E7]"></p>
          </div>
        </div>
      </section>

      <!-- Error -->
      <div id="errorMsg" class="mt-6 hidden">
        <p class="text-sm text-[#f87171] text-center mono"></p>
      </div>
    </main>

    <script>
      // Typewriter animation
      (() => {
        const chars = document.querySelectorAll<HTMLSpanElement>('#typewriter .char');
        const cursor = document.getElementById('cursor')!;
        let i = 0;
        function typeNext() {
          if (i < chars.length) {
            chars[i].classList.add('visible');
            i++;
            setTimeout(typeNext, 150);
          }
        }
        setTimeout(typeNext, 400);
      })();

      const dropZone = document.getElementById("dropZone")!;
      const fileInput = document.getElementById("fileInput") as HTMLInputElement;
      const uploadPrompt = document.getElementById("uploadPrompt")!;
      const uploadSection = document.getElementById("uploadSection")!;
      const loadingState = document.getElementById("loadingState")!;
      const fileNameEl = document.getElementById("fileName")!;
      const progressFill = document.getElementById("progressFill")!;
      const progressLabel = document.getElementById("progressLabel")!;
      const resultSection = document.getElementById("resultSection")!;
      const summaryText = document.getElementById("summaryText")!;
      const copyBtn = document.getElementById("copyBtn")!;
      const errorMsg = document.getElementById("errorMsg")!;

      let progressInterval: ReturnType<typeof setInterval> | null = null;

      function showError(msg: string) {
        errorMsg.querySelector("p")!.textContent = msg;
        errorMsg.classList.remove("hidden");
      }

      function clearError() {
        errorMsg.classList.add("hidden");
      }

      function startProgress() {
        let pct = 0;
        progressFill.style.width = "0%";
        progressLabel.textContent = "Reading PDF...";

        progressInterval = setInterval(() => {
          if (pct < 30) {
            pct += Math.random() * 8 + 2;           // fast to 30%
          } else if (pct < 60) {
            pct += Math.random() * 3 + 0.5;         // medium to 60%
          } else if (pct < 85) {
            pct += Math.random() * 1.5 + 0.2;       // slow to 85%
          } else if (pct < 95) {
            pct += Math.random() * 0.4 + 0.05;      // crawl to 95%
          }
          pct = Math.min(pct, 95);
          progressFill.style.width = `${pct}%`;

          // update label at milestones
          if (pct > 25 && pct < 55) {
            progressLabel.textContent = "Analyzing content...";
          } else if (pct >= 55 && pct < 80) {
            progressLabel.textContent = "Summarizing...";
          } else if (pct >= 80) {
            progressLabel.textContent = "Almost done...";
          }
        }, 300);
      }

      function stopProgress(success: boolean) {
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }
        if (success) {
          progressFill.style.width = "100%";
          progressLabel.textContent = "Done!";
        }
      }

      function setLoading(loading: boolean, name = "") {
        if (loading) {
          uploadPrompt.classList.add("hidden");
          loadingState.classList.remove("hidden");
          fileNameEl.textContent = name;
          fileInput.disabled = true;
          resultSection.classList.add("hidden");
          // Reset drop zone to full size during loading
          dropZone.classList.remove("compact");
          // Move upload section back to top
          const header = document.querySelector("header")!;
          header.after(uploadSection);
          startProgress();
        } else {
          uploadPrompt.classList.remove("hidden");
          loadingState.classList.add("hidden");
          fileInput.disabled = false;
        }
      }

      function fileToBase64(file: File): Promise<string> {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            const result = reader.result as string;
            resolve(result.split(",")[1]); // strip data:...;base64, prefix
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      async function handleFile(file: File) {
        clearError();

        if (file.type !== "application/pdf") {
          showError("That doesn't look like a PDF. Please try a .pdf file.");
          return;
        }

        if (file.size > 25 * 1024 * 1024) {
          showError("That file is too large (max 25 MB).");
          return;
        }

        setLoading(true, file.name);

        try {
          const base64 = await fileToBase64(file);

          const res = await fetch("/api/summarize-pdf", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ pdf: base64, name: file.name }),
          });

          const data = await res.json();

          if (!res.ok) {
            throw new Error(data.error || "Something went wrong");
          }

          stopProgress(true);

          // Short delay so user sees 100%
          await new Promise(r => setTimeout(r, 400));

          setLoading(false);

          // Show result
          resultSection.classList.remove("hidden");
          const card = resultSection.querySelector(".fade-in")!;
          card.classList.remove("fade-in");
          void (card as HTMLElement).offsetWidth;
          card.classList.add("fade-in");
          summaryText.textContent = data.summary;

          // Move drop zone below the result and make it compact
          resultSection.after(uploadSection);
          dropZone.classList.add("compact");
        } catch (e: any) {
          stopProgress(false);
          setLoading(false);
          showError(e.message || "Failed to summarize. Please try again.");
        }
      }

      // Drag & drop
      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("dragover");
      });

      dropZone.addEventListener("dragleave", () => {
        dropZone.classList.remove("dragover");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("dragover");
        const file = e.dataTransfer?.files[0];
        if (file) handleFile(file);
      });

      // File input
      fileInput.addEventListener("change", () => {
        const file = fileInput.files?.[0];
        if (file) handleFile(file);
        fileInput.value = "";
      });

      // Copy — grab the plain text from the formatted HTML
      copyBtn.addEventListener("click", async () => {
        const text = summaryText.innerText || "";
        await navigator.clipboard.writeText(text);
        copyBtn.textContent = "copied!";
        setTimeout(() => (copyBtn.textContent = "copy"), 1500);
      });
    </script>
  </body>
</html>
